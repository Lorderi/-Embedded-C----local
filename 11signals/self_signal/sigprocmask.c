
//при выполнениии наблюдаем что процесс не реагирует на сигнал т.к. он заблокирован
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>


//засыпаем и не загружаем систему когда ждем сигнал

//С заблокированными сигналами: поэтому сначала заблокировать, т.к. если не заблок то будет вызван обработчик сигнала, а мы реагируем на событие
//sigsuspend - заменяем маску и уходим в сон пока сигнал из маски не прийде, ожидаем
//sigwait, ...

//sigprocmask sigusr1 - блокируем сигнал, невозможность вызова диспозиции обработчика, если это не сделать, то
//сначала вызовется обработчик, а потом вернемся из этой функциии и каждый раз будет вызываться обработчик, а это приводит к смерти.

//Если не переопределили диспозиции и не заблокировали sigusr1, послать sigusr1 то программа умрет





//обработчик - переопределение, прерывание значит что основная функция в этот момент ниче не делает
void hdl(int sig, siginfo_t *make, void *arg){
    //диспозиция(функция, код выполняющийся вов время приход сигнала, обработчик прерывания)
    printf("Received signal: %d\n", sig);
    printf("From process %u\n", make->si_pid);
    printf("Done from function\n");
}

int main(void)
{
    struct sigaction sigact;
    memset(&sigact, 0, sizeof(sigact));
    printf("I am process %i\n", getpid());

    sigact.sa_sigaction = &hdl; //либо более простой .sa_handler без доп. полей(инфа и инфа)
    //блокировка в маске работает так: получаем сигнал, вывывается код маски и блокируется что в маскке и выполняется диспозиция, потом восстанавливается и далее
    
    sigset_t set; 
    sigemptyset(&set); //очищение структуры                                                            
    sigaddset(&set, SIGUSR1); //необходимо блокировать эти же сигналы пока выполняется обработчик
    sigprocmask(SIG_BLOCK, &set, 0);
    //либо так: надо или нет не знаю
    //sigact.sa_mask = set; // маска сигналов который будут блокированы пока выполняется наш обработчик. + по дефолту блокируется и сам полученный сигнал
    sigact.sa_flags = SA_SIGINFO; // флаг SIGINFO, вся эта информация будет доступна сразу, т.к. выводим информацию о процессе, который послал сигнал, то лучше этот флаг выставить
    sigaction(SIGUSR1, &sigact, 0); //обработчик для сигналов SIGUSR1
    kill(getpid(), SIGUSR1); //посылаем сигнал себе

    printf("Done from main\n");

    return 0;
}

