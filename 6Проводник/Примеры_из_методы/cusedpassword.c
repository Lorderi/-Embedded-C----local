#include <termios.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <stdlib.h>
#include <curses.h>
#include <string.h>
#define MAX_LEN 15

/*Программа cursedinput (ее исходные тексты вы найдете в файле cursedinput.c) позволяет пользователю вводить строку текста и, затем, распечатывает введенную строку.*/
void sig_winch(int signo){
	struct winsize size;
	ioctl(fileno(stdout), TIOCGWINSZ, (char *) &size);
	resizeterm(size.ws_row, size.ws_col);
	}
/*Функция get_password() считывает символы из входного потока с помощью
функции wgetch() до тех пор, пока пользователь не нажмет ввод, или пока
длина введенной строки не сравняется с максимально допустимой длиной.*/

/*Вызов keypad() с ненулевым вторым параметром приводит к тому, что
клавиши [F1]-[F12] генерируют коды KEY_F1-KEY_F12, клавиши со стрелками
– коды KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, а клавиша [BackSpace] –
код KEY_BACKSPACE (описание других кодов специальных клавиш и событий
вы найдете на странице man функции getch()). Получив в потоке ввода код
KEY_BACKSPACE, мы должны выполнить несколько операций. Прежде всего,
мы стираем только что напечатанную звездочку. Для этого нужно получить
текущие координаты курсора, сдвинуть курсор на одну позицию влево и
напечатать пробел. Затем курсор снова нужно сдвинуть на одну позицию
влево. Получить текущие координаты курсора в окне можно с помощью
макроса getyx(). Первым параметром макроса является идентификатор окна,
вторым параметром – переменная, в которой макрос сохранит значение
строки курсора, третьим параметром – переменная, в которой будет
сохранено значение столбца курсора. Именно потому, что getyx() – макрос, мы
передаем для получения значений переменные, а не указатели на них.
Функция mvwaddch() сочетает перемещение курсора и вывод символа. Первый
параметр функции – идентификатор окна. За ним следуют новые координаты
курсора – строка и столбец. Последним параметром функции является символ,
который нужно напечатать. После того, как мы привели в порядок экран, мы
уменьшаем на единицу счетчик введенных символов (переменная i). Если
переменная i равна нулю, никаких действий не выполняется. Наша функция
get_password() будет работать правильно только в режиме cbreak(). Следует
отметить также, что функция не будет работать корректно с клавишей
[BackSpace], если при вводе пароля произошел перенос строки.*/
void get_password(WINDOW * win, char * password, int max_len){
	int i = 0;
	int ch;
	while (((ch = wgetch(win)) != 10) && (i < max_len-1)) {
		if (ch == KEY_BACKSPACE) {
			int x, y;
			if (i==0) continue;
			getyx(win, y, x);
			mvwaddch(win, y, x-1, ' ');
			/*Для вывода отдельных символов в окно можно применить функцию waddch(), однако мы используем функцию wechochar(), которая эквивалента вызову waddch() с последующим вызовом wrefresh().*/
			wrefresh(win);
			wmove(win, y, x-1);
			i--;
			continue;
		}
		password[i++] = ch;
		wechochar(win, '*');
	}
	password[i] = 0;
	/*Для вывода отдельных символов в окно можно применить функцию waddch(),
однако мы используем функцию wechochar(), которая эквивалента вызову
waddch() с последующим вызовом wrefresh().*/
	wechochar(win, '\n');
}

int main(int argc, char ** argv){
	WINDOW * wnd;
	char password[MAX_LEN + 1], RIGHT_PASSWORD[] = "123";
	initscr();
	signal(SIGWINCH, sig_winch);
	/*курсор видимый*/
	curs_set(TRUE);
	start_color();
	refresh();
	init_pair(1, COLOR_YELLOW, COLOR_BLUE);
	wnd = newwin(5, 23, 2, 2);
	wbkgd(wnd, COLOR_PAIR(1));
	/*необходимо получить код специальной клавиши. По умолчанию при нажатии на специальные клавиши, такие как стрелки, клавиши [F1]-[F12] или [BackSpace], терминал генерирует послед-ть кодов, называемую Esc-посл-ть. чтобы заменить Esc-послед-сть одним специальным кодом, необходимо вызвать функцию keypad() с ненулевым вторым параметром. Первым параметром keypad() должен быть идентификатор окна (wnd).
	
	............
	
	*/
	/*чтобы заменить Esc-последовательность одним специальным кодом,
необходимо вызвать функцию keypad() с ненулевым вторым параметром (что
мы и делаем в главной функции программы). Первым параметром keypad()
должен быть идентификатор окна (в нашем случае – wnd).*/	
	keypad(wnd, TRUE);
	wprintw(wnd, "Enter password...\n");
	get_password(wnd, password, MAX_LEN);
	wattron(wnd, A_BLINK);
	/*Прототип функции strcmp(), которую мы используем
для сравнения переданной пользователем строки и пароля, находится в файле
<string.h>.*/
	if (strcmp(password, RIGHT_PASSWORD) == 0)
		wprintw(wnd, "ACCESS GRANTED!");
	else
		wprintw(wnd, "ACCESS DENIED!");
	
	wrefresh(wnd);
	delwin(wnd);
	/*убираем курсор*/
	curs_set(FALSE);
	move(8, 4);
	printw("Press any key to continue...");
	refresh();
	getch();
	endwin();
	exit(EXIT_SUCCESS);
}
	
	

